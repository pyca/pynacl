from __future__ import absolute_import
from __future__ import division

from . import six

from . import nacl, encoding
from .exceptions import CryptoError


class PublicKey(encoding.Encodable, six.StringFixer, object):
    """
    The public key counterpart to an Ed25519 :class:`nacl.public.PrivateKey`
    for encrypting messages.

    :param public_key: [:class:`bytes`] Encoded Ed25519 public key
    :param encoder: A class that is able to decode the `public_key`
    """

    PUBLICKEY_SIZE = nacl.lib.crypto_box_PUBLICKEYBYTES

    def __init__(self, public_key, encoder=encoding.RawEncoder):
        self._public_key = encoder.decode(public_key)

        if len(self._public_key) != self.PUBLICKEY_SIZE:
            raise ValueError('The public key must be exactly %s bytes long' %
                             self.PUBLICKEY_SIZE)

    def __bytes__(self):
        return self._public_key


class PrivateKey(encoding.Encodable, six.StringFixer, object):
    """
    Private key for decrypting messages using the Ed25519 algorithm.

    .. warning:: This **must** be protected and remain secret. Anyone who
        knows the value of your :class:`~nacl.public.PrivateKey` can decrypt
        any message encrypted by the corresponding
        :class:`~nacl.public.PublicKey`

    :param private_key: The private key used to decrypt messages
    :param encoder: The encoder class used to decode the given keys

    :cvar PRIVATEKEY_SIZE: The size that the private key is required to be
    """

    PRIVATEKEY_SIZE = nacl.lib.crypto_box_SECRETKEYBYTES

    def __init__(self, private_key, encoder=encoding.RawEncoder):
        self._private_key = encoder.decode(private_key)
        self._public_key = None

        if len(self._private_key) != self.PRIVATEKEY_SIZE:
            raise ValueError('The private key must be exactly %s bytes long' %
                             self.PRIVATEKEY_SIZE)

    def __bytes__(self):
        return self._private_key

    @classmethod
    def generate(cls):
        """
        Generates a random :class:`~nacl.public.PrivateKey` object

        :rtype: :class:`~nacl.public.PrivateKey`
        """
        pk = nacl.ffi.new("unsigned char[]", PublicKey.PUBLICKEY_SIZE)
        sk = nacl.ffi.new("unsigned char[]", cls.PRIVATEKEY_SIZE)

        public_key = nacl.ffi.buffer(pk, PublicKey.PUBLICKEY_SIZE)[:]
        private_key = nacl.ffi.buffer(sk, cls.PRIVATEKEY_SIZE)[:]

        if not nacl.lib.crypto_box_keypair(public_key, private_key):
            raise CryptoError("Failed to generate key pair")

        sk = cls(private_key)
        sk.public_key = public_key

        return sk

    @property
    def public_key(self):
        return self._public_key

    @public_key.setter
    def public_key(self, value):
        self._public_key = value


class Box(encoding.Encodable, six.StringFixer, object):
    """
    The Box class boxes and unboxes messages between a pair of keys

    The ciphertexts generated by :class:`~nacl.public.Box` include a 16
    byte authenticator which is checked as part of the decryption. An invalid
    authenticator will cause the decrypt function to raise an exception. The
    authenticator is not a signature. Once you've decrypted the message you've
    demonstrated the ability to create arbitrary valid message, so messages you
    send are repudiable. For non-repudiable messages, sign them after
    encryption.

    :param public_key: :class:`~nacl.public.PublicKey` used to encrypt and
        decrypt messages
    :param private_key: :class:`~nacl.public.PrivateKey` used to encrypt and
        decrypt messages

    :cvar NONCE_SIZE: The size that the nonce is required to be.
    """

    NONCE_SIZE = nacl.lib.crypto_box_NONCEBYTES

    def __init__(self, public_key, private_key):
        self._pk = public_key._public_key
        self._sk = private_key._private_key
        self._shared_key = None

    def __bytes__(self):
        return self._sk

    def encrypt(self, plaintext, nonce, encoder=encoding.RawEncoder):
        """
        Encrypts the plaintext message using the given `nonce` and returns
        the ciphertext encoded with the encoder.

        .. warning:: It is **VITALLY** important that the nonce is a nonce,
            i.e. it is a number used only once for any given key. If you fail
            to do this, you compromise the privacy of the messages encrypted.

        :param plaintext: [:class:`bytes`] The plaintext message to encrypt
        :param nonce: [:class:`bytes`] The nonce to use in the encryption
        :param encoder: The encoder to use to encode the ciphertext
        :rtype: [:class:`bytes`]
        """
        if len(nonce) != self.NONCE_SIZE:
            raise ValueError('The nonce must be exactly %s bytes long' %
                             self.NONCE_SIZE)

        padded = b"\x00" * nacl.lib.crypto_box_ZEROBYTES + plaintext
        ciphertext = nacl.ffi.new("unsigned char[]", len(padded))

        if not nacl.lib.crypto_box_afternm(
                    ciphertext,
                    padded,
                    len(padded),
                    nonce,
                    self._beforenm()
                ):
            raise CryptoError("Encryption failed")

        box_zeros = nacl.lib.crypto_box_BOXZEROBYTES
        ciphertext = nacl.ffi.buffer(ciphertext, len(padded))[box_zeros:]

        return encoder.encode(ciphertext)

    def decrypt(self, ciphertext, nonce, encoder=encoding.RawEncoder):
        """
        Decrypts the ciphertext using the given nonce and returns the
        plaintext message.

        :param ciphertext: [:class:`bytes`] The encrypted message to decrypt
        :param nonce: [:class:`bytes`] The nonce used when encrypting the
            ciphertext
        :param encoder: The encoder used to decode the ciphertext.
        :rtype: [:class:`bytes`]
        """
        if len(nonce) != self.NONCE_SIZE:
            raise ValueError('The nonce must be exactly %s bytes long' %
                             self.NONCE_SIZE)

        ciphertext = encoder.decode(ciphertext)

        padded = b"\x00" * nacl.lib.crypto_box_BOXZEROBYTES + ciphertext
        plaintext = nacl.ffi.new("unsigned char[]", len(padded))

        if not nacl.lib.crypto_box_open_afternm(
                    plaintext,
                    padded,
                    len(padded),
                    nonce,
                    self._beforenm()
                ):
            raise CryptoError(
                        'Decryption failed. Ciphertext failed verification')

        box_zeros = nacl.lib.crypto_box_ZEROBYTES
        plaintext = nacl.ffi.buffer(plaintext, len(padded))[box_zeros:]

        return plaintext

    def _beforenm(self):
        if self._shared_key is not None:
            return self._shared_key

        sharedkey_size = nacl.lib.crypto_box_BEFORENMBYTES

        k = nacl.ffi.new("unsigned char[]", sharedkey_size)

        if not nacl.lib.crypto_box_beforenm(k, self._pk, self._sk):
            raise CryptoError("Failed to derive shared key")

        self._shared_key = nacl.ffi.buffer(k, sharedkey_size)[:]
        return self._shared_key
